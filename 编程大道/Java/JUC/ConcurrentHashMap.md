# 并发 HashMap

## Java8 ConcurrentHashMap

<!-- notecardId: 1735049009102 -->

> 关键点: 分段锁，CAS，红黑树

### 实现原理

Java 8 中的 `ConcurrentHashMap` 采用了分段锁和 CAS 操作来实现高效并发。主要特点包括：

1. 数据结构
   在 Java 8 中，ConcurrentHashMap 主要由以下几个部分组成：
   - Node 数组：ConcurrentHashMap 的底层是一个 Node<K,V>[] 数组，每个元素是一个链表或红黑树的头节点。
   - Node 节点：每个 Node 包含一个键值对和一个指向下一个节点的引用。
   - TreeNode 节点：当链表长度超过一定阈值（默认是 8）时，链表会转换为红黑树，Node 节点会变成 TreeNode 节点。
   - 桶（bucket）是用于存储键值对的基本单位。每个桶对应一个数组元素，数组的每个元素可以是一个链表的头节点或红黑树的根节点。
   - 每个桶可以存储一个或多个键值对，当发生哈希冲突时，多个键值对会存储在同一个桶中。
2. CAS 操作
   CAS（Compare-And-Swap）是一种无锁的并发编程技术，用于实现原子操作。ConcurrentHashMap 使用 CAS 操作来保证并发安全，减少锁的使用。例如，在插入新节点时，会使用 CAS 操作来确保只有一个线程能够成功插入。

3. 分段锁
   虽然 Java 8 中取消了 Segment，但仍然通过分段锁机制来减少锁的粒度。具体实现是通过对每个桶（bucket）进行加锁，而不是对整个 ConcurrentHashMap 加锁，从而提高并发性能。

4. 红黑树
   当链表长度超过一定阈值（默认是 8）时，链表会转换为红黑树。红黑树是一种自平衡二叉搜索树，能够在 O(log n) 时间内完成插入、删除和查找操作，从而提高查询效率。

5. 扩容机制
   ConcurrentHashMap 的扩容机制也进行了优化。扩容时，采用分段扩容的方式，即每次只扩容一个桶，减少扩容时的性能开销。
6. 哈希函数
   - ConcurrentHashMap 使用了一种特殊的哈希函数，称为 MurmurHash3，它能够在保持高性能的同时，提供较好的哈希分布。
   - ConcurrentHashMap 使用哈希函数将键映射到数组中的某个桶。
   - 哈希函数的目的是尽量均匀地分布键值对，减少哈希冲突。

### 锁的实现

在 `ConcurrentHashMap` 中，锁的实现主要依赖于 CAS 操作和内置的同步机制。具体来说：

- **CAS 操作**：通过 `Unsafe` 类提供的 `compareAndSwap` 方法来实现无锁操作，保证原子性。
- **内置锁**：在某些情况下，仍然需要使用 `synchronized` 关键字来保证线程安全，例如在链表或红黑树的插入和删除操作中。

### get 方法的实现细节

`ConcurrentHashMap` 的 `get` 方法是无锁的，具体步骤如下：

1. **定位桶**：根据键的 `hashCode` 计算出桶的位置。
2. **遍历链表或红黑树**：在对应的桶中，遍历链表或红黑树，查找匹配的键。
3. **返回值**：如果找到匹配的键，返回对应的值；否则返回 `null`。

### put 方法的实现细节

`ConcurrentHashMap` 的 `put` 方法使用了 CAS 操作和内置锁，具体步骤如下：

1. **定位桶**：根据键的 `hashCode` 计算出桶的位置。
2. **CAS 插入**：如果桶为空，使用 CAS 操作插入新节点。
3. **遍历链表或红黑树**：如果桶不为空，使用 synchronized 锁定桶,遍历链表或红黑树，查找匹配的键。
   - **更新值**：如果找到匹配的键，更新对应的值。
   - **插入新节点**：如果未找到匹配的键，插入新节点到链表或红黑树中。
4. **扩容检查**：插入新节点后，检查是否需要扩容，如果需要则进行分段扩容。

### 数组扩容

> 1. 分段迁移：扩容时，ConcurrentHashMap 会将迁移任务分配给多个线程，每个线程负责迁移一部分桶的数据。
> 2. ForwardingNode：在迁移过程中，使用 ForwardingNode 标记已经迁移的桶，避免重复迁移。
> 3. 双倍容量：新数组的容量是旧数组的两倍，减少了哈希冲突的概率。

- 当 ConcurrentHashMap 中的元素数量超过当前数组容量的负载因子（默认是 0.75）时，就会触发扩容操作。
- 扩容过程
  1. 创建新数组：
     - 创建一个新的数组，容量是原数组的两倍。
  2. 迁移数据：
     - 将旧数组中的元素重新分配到新数组中。由于数组容量翻倍，元素的位置可能会发生变化。
     - 迁移过程中，使用分段迁移的方式，即每次只迁移一个桶，减少扩容时的性能开销。
  3. **分段迁移**：
     - 扩容时，ConcurrentHashMap 会将迁移任务分配给多个线程，每个线程负责迁移一部分桶的数据。
     - 通过使用 MOVED 标记已经迁移的桶，避免重复迁移。

### 改进

相比 Java 7，Java 8 中的 `ConcurrentHashMap` 进行了以下改进：

- **取消了 Segment**：Java 8 中取消了 Segment，改为使用 Node 数组和 CAS 操作来实现并发控制。
- **引入红黑树**：当链表长度超过 8 时，链表会转换为红黑树，优化查询性能。
- **优化扩容机制**：采用分段扩容，减少扩容时的性能开销。

### 常见面试题

> **Q: ConcurrentHashMap 的实现原理是什么？**

- A: 采用分段锁和 CAS 操作来实现高效并发，使用红黑树优化查询性能。

> **Q: Java 8 中 ConcurrentHashMap 相比 Java 7 有哪些改进？**

- A: 取消了 Segment，改为使用 Node 数组和 CAS 操作；引入红黑树；优化扩容机制。

> **Q: ConcurrentHashMap 如何保证线程安全？**

- A: 通过 CAS 操作和分段锁机制来保证线程安全。

### 应用场景

- **高并发环境**：适用于高并发读写的场景，如缓存系统、计数器等。
- **多线程数据共享**：适用于多线程环境下的数据共享，保证线程安全和高效访问。
