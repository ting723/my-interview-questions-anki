# lock

## 常用的锁

<!-- notecardId: 1735193140507 -->

### 1. ReentrantLock

#### 优点

- 支持公平锁和非公平锁
- 提供了比 `synchronized` 更加灵活的锁机制
- 支持中断锁等待
- 支持条件变量（Condition）

#### 缺点

- 使用较为复杂，需要手动释放锁
- 性能开销相对较大

#### 作用

- 用于替代 `synchronized` 实现更复杂的同步需求

#### 使用场景

- 需要公平锁的场景
- 需要中断锁等待的场景
- 需要多个条件变量的场景

#### 底层实现机制

- 基于 AQS（AbstractQueuedSynchronizer）实现

### 2. ReadWriteLock (ReentrantReadWriteLock)

#### 优点

- 读写分离，提高并发性能
- 读锁共享，写锁独占

#### 缺点

- 适用于读多写少的场景，写多时性能不佳
- 实现复杂，使用不当可能导致死锁

#### 作用

- 提高读多写少场景下的并发性能

#### 使用场景

- 缓存系统
- 读多写少的数据结构

#### 底层实现机制

- 基于 AQS 实现，内部维护了两个锁（读锁和写锁）

### 3. StampedLock

#### 优点

- 提供了乐观读锁，进一步提高并发性能
- 支持读写锁和乐观读锁

#### 缺点

- 使用复杂，容易出错
- 不支持条件变量

#### 作用

- 提供更高性能的读写锁

#### 使用场景

- 高并发读多写少的场景

#### 底层实现机制

- 基于版本号的乐观锁机制

### 4. LockSupport

#### 优点

- 提供了线程阻塞和唤醒的低级工具
- 灵活性高

#### 缺点

- 使用复杂，需要手动管理线程状态
- 容易导致死锁或线程泄漏

#### 作用

- 实现自定义的同步工具

#### 使用场景

- 需要自定义同步工具的场景

#### 底层实现机制

- 基于 Unsafe 类的 park 和 unpark 方法

### 5. Condition

#### 优点

- 提供了比 `Object` 的 `wait` 和 `notify` 更加灵活的等待/通知机制
- 支持多个条件变量

#### 缺点

- 需要与 `Lock` 配合使用
- 使用复杂

#### 作用

- 实现复杂的等待/通知机制

#### 使用场景

- 需要多个条件变量的场景

#### 底层实现机制

- 基于 AQS 实现

### 6. Semaphore

#### 优点

- 控制同时访问资源的线程数量
- 提供公平和非公平模式

#### 缺点

- 使用复杂，需要手动管理许可

#### 作用

- 限制资源的并发访问数量

#### 使用场景

- 限流
- 连接池

#### 底层实现机制

- 基于 AQS 实现，通过计数器控制许可数量

### 7. CountDownLatch

#### 优点

- 允许一个或多个线程等待其他线程完成操作
- 简单易用

#### 缺点

- 只能使用一次

#### 作用

- 实现线程间的协调

#### 使用场景

- 并行计算
- 多线程启动同步

#### 底层实现机制

- 基于 AQS 实现，通过计数器控制线程等待

### 8. CyclicBarrier

#### 优点

- 允许一组线程互相等待，直到所有线程都到达屏障
- 可重复使用

#### 缺点

- 使用复杂，可能导致死锁

#### 作用

- 实现多线程间的同步

#### 使用场景

- 多线程计算
- 并行任务分段执行

#### 底层实现机制

- 基于 ReentrantLock 和 Condition 实现，通过计数器和屏障动作控制线程同步
