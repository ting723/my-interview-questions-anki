# 锁

## Java 并发工具包 (JUC) 中的各种锁

<!-- notecardId: 1735275258113 -->

### 1. 偏向锁 (Biased Locking)

偏向锁是一种优化机制，旨在减少无竞争情况下的同步开销。当一个线程获得锁时，锁会偏向该线程，后续该线程再次请求锁时无需进行同步操作。偏向锁适用于大多数情况下锁竞争较少的场景。

#### 特点

- 适用于无竞争的场景
- 减少了加锁和解锁的开销
- 当出现竞争时，会撤销偏向锁

### 2. 轻量级锁 (Lightweight Lock)

轻量级锁是指在无竞争的情况下，通过 CAS 操作来避免使用重量级锁，从而提高性能。当锁竞争发生时，轻量级锁会膨胀为重量级锁。

#### 特点

- 适用于竞争不激烈的场景
- 使用 CAS 操作进行加锁和解锁
- 竞争激烈时会膨胀为重量级锁

### 3. 重量级锁 (Heavyweight Lock)

重量级锁是传统的锁机制，使用操作系统的互斥量（Mutex）实现。当线程竞争激烈时，轻量级锁会膨胀为重量级锁，导致线程阻塞和唤醒的开销增加。

#### 特点

- 适用于竞争激烈的场景
- 使用操作系统的互斥量实现
- 线程阻塞和唤醒开销较大

### 4. 自旋锁 (Spin Lock)

自旋锁是指线程在获取锁失败时，不会立即阻塞，而是通过循环等待的方式不断尝试获取锁。自旋锁适用于锁持有时间较短的场景，可以减少线程上下文切换的开销。

#### 特点

- 适用于锁持有时间较短的场景
- 通过循环等待获取锁
- 避免了线程阻塞和唤醒的开销

### 5. 读写锁 (Read-Write Lock)

读写锁允许多个读线程同时访问共享资源，但在写线程访问时，所有读线程和其他写线程都会被阻塞。读写锁适用于读多写少的场景。

#### 特点

- 适用于读多写少的场景
- 读线程可以并发访问
- 写线程独占访问

### 6. 可重入锁 (Reentrant Lock)

可重入锁是一种递归锁，允许同一个线程多次获取同一把锁而不会发生死锁。Java 中的 `ReentrantLock` 类实现了可重入锁。

#### 特点

- 允许同一线程多次获取锁
- 提供了更多的功能，如公平锁和非公平锁选择

### 7. 公平锁 (Fair Lock) 和 非公平锁 (Unfair Lock)

公平锁保证线程获取锁的顺序是按照请求锁的顺序进行的，而非公平锁则不保证顺序，可能会导致某些线程长时间等待。

#### 特点

- 公平锁：保证锁的获取顺序，性能较低
- 非公平锁：不保证顺序，性能较高

### 8. 互斥锁 (Mutex)

互斥锁是一种独占锁，保证同一时间只有一个线程能够访问共享资源。Java 中的 `synchronized` 关键字和 `ReentrantLock` 都是互斥锁的实现。

#### 特点

- 保证同一时间只有一个线程访问资源
- 防止数据竞争和不一致性

### 9. 条件锁 (Condition Lock)

条件锁允许线程在某个条件不满足时等待，并在条件满足时被唤醒。Java 中的 `Condition` 接口提供了条件锁的实现。

#### 特点

- 允许线程在条件不满足时等待
- 提供了 `await` 和 `signal` 方法进行线程通信
