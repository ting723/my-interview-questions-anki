# Java8 GC

## Java 8 常见的垃圾收集器

<!-- notecardId: 1735051994915 -->

### 详细阐述

1. **Serial 收集器**
    - 单线程收集器，适用于单核处理器和小型应用。
    - 在进行垃圾收集时会暂停所有应用线程（Stop-The-World）。

2. **Parallel 收集器**
    - 多线程收集器，适用于多核处理器和高吞吐量的应用。
    - 也会暂停所有应用线程，但通过多线程提高垃圾收集效率。

3. **CMS（Concurrent Mark-Sweep）收集器**
    - 低停顿收集器，适用于需要低延迟的应用。
    - 通过并发标记和清除阶段减少应用线程的停顿时间。

4. **G1（Garbage-First）收集器**
    - 适用于多核处理器和大内存的应用。
    - 将堆划分为多个区域，优先回收垃圾最多的区域，减少停顿时间。

### 常见面试题

**Q1: 什么是 Stop-The-World（STW）？**

A1: Stop-The-World 是指在垃圾收集过程中，JVM 会暂停所有应用线程，以便进行垃圾收集操作。这种暂停会影响应用的响应时间。

**Q2: CMS 收集器的主要优点是什么？**

A2: CMS 收集器的主要优点是低停顿时间，适用于对响应时间要求较高的应用。它通过并发标记和清除阶段减少了应用线程的停顿时间。

**Q3: G1 收集器与 CMS 收集器相比有什么优势？**

A3: G1 收集器相比 CMS 收集器的主要优势在于更好的预测性和可控的停顿时间。G1 收集器通过分区和优先回收垃圾最多的区域，能够更好地控制垃圾收集的停顿时间。

### 垃圾收集器采用的算法

1. **标记-清除算法**
    - 标记出所有存活对象，然后清除未标记的对象。
    - 缺点是会产生内存碎片。

2. **复制算法**
    - 将存活对象复制到另一块内存区域，然后清除原内存区域。
    - 优点是没有内存碎片，缺点是需要额外的内存空间。

3. **标记-整理算法**
    - 标记出所有存活对象，然后将存活对象移动到内存的一端，最后清除未标记的对象。
    - 优点是没有内存碎片，适用于老年代的垃圾收集。

4. **分代收集算法**
    - 根据对象的存活时间将内存划分为新生代和老年代，不同代采用不同的垃圾收集算法。
    - 新生代通常采用复制算法，老年代通常采用标记-整理算法。

### 结合 JMM 模型介绍

Java 内存模型（JMM）定义了线程如何通过内存进行交互。JMM 规定了变量的可见性和有序性，确保了多线程环境下的内存一致性。垃圾收集器在进行垃圾收集时，需要考虑到 JMM 的规定，确保在垃圾收集过程中不会破坏内存的一致性和线程的可见性。
