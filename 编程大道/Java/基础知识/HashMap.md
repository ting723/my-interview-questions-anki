# Java 8 HashMap 实现详解

## JavaHashMap概述

<!-- notecardId: 1735049283290 -->

### Java 8 HashMap 实现

Java 8 对 HashMap 进行了许多优化和改进，主要包括以下几个方面：

1. **数据结构**：Java 8 之前，HashMap 主要使用数组和链表来存储键值对。当发生哈希冲突时，冲突的键值对会被存储在链表中。Java 8 引入了红黑树，当链表长度超过一定阈值（默认是 8）时，链表会转换为红黑树，以提高查询效率。

2. **哈希函数**：Java 8 对哈希函数进行了优化，减少了哈希冲突的概率。通过对哈希值进行扰动处理，使得哈希值更加均匀地分布在数组中。

3. **扩容机制**：当 HashMap 中的元素数量超过数组容量的负载因子（默认是 0.75）时，HashMap 会进行扩容。扩容时，数组容量会翻倍，并重新计算每个元素的哈希值，将其放入新的数组中。

4. **查询效率**：Java 8 对查询效率进行了优化，通过红黑树来提高查询效率。当链表长度超过一定阈值时，链表会转换为红黑树，以提高查询效率。

### 常见面试题

> Q1: Java 8 中 HashMap 的底层数据结构是什么？

**A1**: Java 8 中 HashMap 的底层数据结构是数组和链表/红黑树的结合体。当发生哈希冲突时，冲突的键值对会被存储在链表中。当链表长度超过一定阈值（默认是 8）时，链表会转换为红黑树。

> Q2: Java 8 中 HashMap 如何解决哈希冲突？

**A2**: Java 8 中 HashMap 通过链表和红黑树来解决哈希冲突。当发生哈希冲突时，冲突的键值对会被存储在链表中。当链表长度超过一定阈值（默认是 8）时，链表会转换为红黑树，以提高查询效率。

> Q3: Java 8 中 HashMap 的扩容机制是怎样的？

**A3**: 当 HashMap 中的元素数量超过数组容量的负载因子（默认是 0.75）时，HashMap 会进行扩容。扩容时，数组容量会翻倍，并重新计算每个元素的哈希值，将其放入新的数组中。

> Q4: 为什么 Java 8 中引入了红黑树？

**A4**: Java 8 中引入红黑树是为了提高查询效率。当链表长度超过一定阈值（默认是 8）时，链表会转换为红黑树。红黑树的查询时间复杂度为 O(log n)，而链表的查询时间复杂度为 O(n)，因此红黑树可以显著提高查询效率。

> Q5: HashMap 是线程安全的吗？

**A5**: HashMap 不是线程安全的。如果需要在多线程环境中使用 HashMap，可以使用 `Collections.synchronizedMap` 方法将 HashMap 包装成线程安全的，或者使用 `ConcurrentHashMap`。
