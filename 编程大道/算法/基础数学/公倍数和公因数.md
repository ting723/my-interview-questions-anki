# 基础数学

## 最小公倍数和最大公因数

<!-- notecardId: 1736566285908 -->

### **求最大公因数的方法**

- **列举法**
  - 分别列出两个数（或多个数）的因数，然后找出它们共有的因数，其中最大的那个就是最大公因数。
  - 例如，求 18 和 24 的最大公因数。18 的因数有 1、2、3、6、9、18；24 的因数有 1、2、3、4、6、8、12、24。它们共有的因数是 1、2、3、6，所以 18 和 24 的最大公因数是 6。
- **分解质因数法**
  - 把每个数分解成若干个质因数相乘的形式，然后找出它们公有的质因数，并将这些公有的质因数相乘，所得的积就是最大公因数。
  - 例如，求 30 和 42 的最大公因数。先将 30 分解质因数为$$30 = 2×3×5$$，42 分解质因数为$$42=2×3×7$$，公有的质因数是 2 和 3，所以 30 和 42 的最大公因数是$$2×3 = 6$$。
- **短除法**
  - 用两个数公有的质因数去除这两个数，一直除到所得的商互质为止。然后把所有的除数相乘，所得的积就是这两个数的最大公因数。
  - 例如，求 48 和 60 的最大公因数。先用 2 去除 48 和 60，得到商 24 和 30；再用 2 去除 24 和 30，得到商 12 和 15；接着用 3 去除 12 和 15，得到商 4 和 5，4 和 5 互质。除数 2、2、3 相乘，$$2×2×3 = 12$$，所以 48 和 60 的最大公因数是 12。

### **求最小公倍数的方法**

- **列举法**
  - 分别列出两个数（或多个数）的倍数，然后找出它们公有的倍数，其中最小的那个就是最小公倍数。
  - 例如，求 6 和 8 的最小公倍数。6 的倍数有 6、12、18、24、30、36……；8 的倍数有 8、16、24、32、40……。它们公有的倍数有 24、48……，所以 6 和 8 的最小公倍数是 24。
- **分解质因数法**
  - 把每个数分解成若干个质因数相乘的形式，然后将所有质因数（相同的质因数取最多的次数）相乘，所得的积就是最小公倍数。
  - 例如，求 12 和 18 的最小公倍数。12 分解质因数为$$12 = 2×2×3$$，18 分解质因数为$$18 = 2×3×3$$。最小公倍数为$$2×2×3×3= 36$$。
- **短除法**
  - 用两个数公有的质因数去除这两个数，一直除到所得的商互质为止。然后把所有的除数和最后的商相乘，所得的积就是这两个数的最小公倍数。
  - 例如，求 24 和 36 的最小公倍数。先用 2 去除 24 和 36，得到商 12 和 18；再用 2 去除 12 和 18，得到商 6 和 9；接着用 3 去除 6 和 9，得到商 2 和 3，2 和 3 互质。除数 2、2、3 与最后的商 2、3 相乘，$$2×2×3×2×3 = 72$$，所以 24 和 36 的最小公倍数是 72。

### 辗转相除法

**辗转相除法**（又称欧几里得算法，Euclidean Algorithm）是一种用于计算两个整数的**最大公因数**（Greatest Common Divisor, GCD）的高效算法。它的基本思想是通过反复用较小数去除较大数，直到余数为 0，此时的除数就是最大公因数。

---

#### 辗转相除法的原理

1. **基本思想**：

   - 对于两个整数 $$a$$ 和 $$b$$（假设 $$a > b$$），它们的最大公因数等于 $$b$$ 和 $$a \mod b$$ 的最大公因数。
   - 即：$$\gcd(a, b) = \gcd(b, a \mod b)$$。

2. **终止条件**：

   - 当 $$a \mod b = 0$$ 时，$$b$$ 就是最大公因数。

3. **递归实现**：

   - 通过递归调用，不断缩小问题规模，直到余数为 0。

4. **迭代实现**：
   - 通过循环实现，避免递归调用的开销。

---

#### 辗转相除法的步骤

1. **输入**：两个整数 $$a$$ 和 $$b$$。
2. **步骤**：
   - 如果 $$b = 0$$，则返回 $$a$$。
   - 否则，计算 $$a \mod b$$，并用 $$b$$ 和 $$a \mod b$$ 替换原来的 $$a$$ 和 $$b$$。
   - 重复上述步骤，直到 $$b = 0$$。
3. **输出**：$$a$$ 就是最大公因数。

---

#### 递归实现

以下是辗转相除法的递归实现：

```java
public class GCD {
    // 递归实现辗转相除法
    public static int gcd(int a, int b) {
        if (b == 0) {
            return a; // 当 b 为 0 时，a 就是最大公因数
        }
        return gcd(b, a % b); // 递归调用
    }

    public static void main(String[] args) {
        int a = 56;
        int b = 98;
        System.out.println("GCD of " + a + " and " + b + " is: " + gcd(a, b));
    }
}
```

---

#### 迭代实现

以下是辗转相除法的迭代实现：

```java
public class GCD {
    // 迭代实现辗转相除法
    public static int gcd(int a, int b) {
        while (b != 0) {
            int temp = b;
            b = a % b;
            a = temp;
        }
        return a; // 当 b 为 0 时，a 就是最大公因数
    }

    public static void main(String[] args) {
        int a = 56;
        int b = 98;
        System.out.println("GCD of " + a + " and " + b + " is: " + gcd(a, b));
    }
}
```

---

#### 示例运行

##### 输入

```java
int a = 56;
int b = 98;
```

##### 输出

```
GCD of 56 and 98 is: 14
```

##### 计算过程

1. 第一次迭代：$$a = 98$$, $$b = 56$$, $$98 \mod 56 = 42$$。
2. 第二次迭代：$$a = 56$$, $$b = 42$$, $$56 \mod 42 = 14$$。
3. 第三次迭代：$$a = 42$$, $$b = 14$$, $$42 \mod 14 = 0$$。
4. 终止条件：$$b = 0$$，返回 $$a = 14$$。

---

#### 辗转相除法的优点

1. **高效**：

   - 时间复杂度为 $$O(\log(\min(a, b)))$$，非常高效。
   - 每次迭代至少将问题规模减半。

2. **简单易实现**：

   - 算法逻辑简单，代码实现容易。

3. **适用范围广**：
   - 适用于任意大小的整数。

---

#### 扩展：最小公倍数

通过最大公因数可以快速计算两个数的最小公倍数（Least Common Multiple, LCM）：

$$
\text{LCM}(a, b) = \frac{|a \times b|}{\gcd(a, b)}
$$

##### 代码实现

```java
public class LCM {
    public static int lcm(int a, int b) {
        return Math.abs(a * b) / gcd(a, b);
    }

    // 辗转相除法求最大公因数
    public static int gcd(int a, int b) {
        while (b != 0) {
            int temp = b;
            b = a % b;
            a = temp;
        }
        return a;
    }

    public static void main(String[] args) {
        int a = 56;
        int b = 98;
        System.out.println("LCM of " + a + " and " + b + " is: " + lcm(a, b));
    }
}
```

##### 输出

```text
LCM of 56 and 98 is: 392
```

---

#### 总结

- 辗转相除法是一种高效计算最大公因数的算法。
- 通过递归或迭代实现，时间复杂度为 $$O(\log(\min(a, b)))$$。
- 可以扩展用于计算最小公倍数。
- 适用于任意大小的整数，是数论和算法中的经典方法。
