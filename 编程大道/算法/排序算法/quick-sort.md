# Sort

## 快速排序 (Quick Sort)

<!-- notecardId: 1735194721568 -->

快速排序是一种高效的排序算法，通常用于对大量数据进行排序。它的基本思想是通过一个分治法策略来将一个数组分成两个子数组，然后递归地对这两个子数组进行排序。

### 通俗讲解

1. **选择基准点**: 从数组中选择一个元素作为基准点（pivot）。
2. **分区操作**: 将数组中所有比基准点小的元素放在基准点的左边，所有比基准点大的元素放在基准点的右边。
3. **递归排序**: 对基准点左边和右边的子数组分别进行快速排序。
4. **合并结果**: 由于每次分区操作后，基准点已经处于正确的位置，因此不需要再对基准点进行操作，直接合并结果即可。

### 现实世界类比

1. **选择基准点**: 想象你在整理书架，你选择一本书作为基准点（pivot）。
2. **分区操作**: 你将所有比基准点书薄的书放在左边，比基准点书厚的书放在右边。就像在整理书架时，你把小书放在一边，大书放在另一边。
3. **递归排序**: 现在，你分别对左边和右边的书重复同样的操作。就像你继续整理每一堆书，直到每一堆书都按厚度排好。
4. **合并结果**: 最后，你把所有整理好的书堆合并起来。由于每次分区操作后，基准点已经处于正确的位置，因此不需要再对基准点进行操作，直接合并结果即可。

通过这种方式，你可以更直观地理解快速排序的过程。每次选择一个基准点，然后将书架上的书分成两部分，分别整理，最终得到一个有序的书架。

### 优点

- **时间复杂度低**: 平均情况下，快速排序的时间复杂度为 O(n log n)，比许多其他排序算法更高效。
- **空间利用率高**: 快速排序是原地排序算法，不需要额外的存储空间。
- **实现简单**: 快速排序的实现相对简单，且适用于各种数据集。

### 缺点

- **最坏情况时间复杂度高**: 在最坏情况下（例如，每次选择的基准点都是数组的最大或最小值），时间复杂度为 O(n^2)。
- **不稳定**: 快速排序不是稳定排序算法，相同的元素在排序后可能会改变相对顺序。

### 空间和时间复杂度分析

- **时间复杂度**:

  - 最优情况: O(n log n)
  - 平均情况: O(n log n)
  - 最坏情况: O(n^2)

- **空间复杂度**:
  - 最优情况: O(log n) （递归调用栈的空间）
  - 最坏情况: O(n) （递归调用栈的空间）

### Go 语言实现

```go
package main

import (
        "fmt"
)

// 快速排序函数
func quickSort(arr []int) []int {
        if len(arr) < 2 {
                return arr
        }

        left, right := 0, len(arr)-1

        // 选择基准点
        pivotIndex := len(arr) / 2

        // 将基准点移到数组的末尾
        arr[pivotIndex], arr[right] = arr[right], arr[pivotIndex]

        // 分区操作
        for i := range arr {
                if arr[i] < arr[right] {
                        arr[i], arr[left] = arr[left], arr[i]
                        left++
                }
        }

        // 将基准点移到正确的位置
        arr[left], arr[right] = arr[right], arr[left]

        // 递归排序
        quickSort(arr[:left])
        quickSort(arr[left+1:])

        return arr
}

func main() {
        arr := []int{10, 7, 8, 9, 1, 5}
        fmt.Println("未排序数组:", arr)
        sortedArr := quickSort(arr)
        fmt.Println("已排序数组:", sortedArr)
}
```

在这个实现中，我们首先选择一个基准点，然后通过分区操作将数组分成两个子数组，最后递归地对这两个子数组进行排序。最终得到的数组就是有序的。
