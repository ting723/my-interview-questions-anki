# 动态规划

## 放苹果问题

<!-- notecardId: 1736524057640 -->

### 问题描述

有 `m` 个苹果和 `n` 个盘子，将苹果放入盘子中，允许有的盘子是空的，问有多少种不同的分法？

### 输入描述

输入两个整数 `m` 和 `n`，分别表示苹果的个数和盘子的个数。

### 输出描述

输出一个整数，表示不同的分法数目。

### 示例

输入:

```text
7 3
```

输出:

```text
8
```

### 分析

这是一个典型的动态规划问题。我们可以使用一个二维数组 `dp` 来存储状态，其中 `dp[i][j]` 表示将 `i` 个苹果放入 `j` 个盘子的分法数目。

#### 状态转移方程

1. 如果盘子数 `j` 大于苹果数 `i`，则多余的盘子是没有意义的，等价于 `dp[i][i]`。
2. 如果盘子数 `j` 小于等于苹果数 `i`，则可以分为两种情况：
   - 至少有一个盘子是空的，此时分法数目等价于 `dp[i][j-1]`。
   - 每个盘子至少有一个苹果，此时分法数目等价于 `dp[i-j][j]`。

因此，状态转移方程为：

```text
dp[i][j] = dp[i][j-1] + dp[i-j][j]
```

#### 初始条件

- 当没有苹果时，只有一种分法，即所有盘子都是空的：`dp[0][j] = 1`。
- 当只有一个盘子时，只有一种分法，即所有苹果都放在这个盘子里：`dp[i][1] = 1`。

### 示例代码（Go 语言）

```go
package main

import "fmt"

func countWays(m int, n int) int {
     dp := make([][]int, m+1)
     for i := range dp {
          dp[i] = make([]int, n+1)
     }

     for i := 0; i <= m; i++ {
          dp[i][1] = 1
     }
     for j := 0; j <= n; j++ {
          dp[0][j] = 1
     }

     for i := 1; i <= m; i++ {
          for j := 2; j <= n; j++ {
                if i >= j {
                     dp[i][j] = dp[i][j-1] + dp[i-j][j]
                } else {
                     dp[i][j] = dp[i][j-1]
                }
          }
     }

     return dp[m][n]
}

func main() {
     var m, n int
     fmt.Scan(&m, &n)
     fmt.Println(countWays(m, n))
}
```
