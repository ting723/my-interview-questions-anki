# 动态规划

## 走方格问题

<!-- notecardId: 1736523742127 -->

### 问题描述

在一个 `m x n` 的方格中，从左上角走到右下角，每次只能向下或者向右走一步，问有多少种不同的路径？

### 分析

这是一个典型的动态规划问题，可以通过以下步骤解决：

1. **定义状态**：

   - 用 `dp[i][j]` 表示从左上角走到 `(i, j)` 的路径数。

2. **状态转移方程**：

   - 如果只能向下或者向右走，那么 `dp[i][j]` 可以从 `dp[i-1][j]` 或 `dp[i][j-1]` 转移过来，即：
     \[
     dp[i][j] = dp[i-1][j] + dp[i][j-1]
     \]

3. **初始化**：

   - 第一行和第一列的路径数都为 1，因为从起点到这些位置只有一种路径（一直向右或一直向下）。

4. **计算顺序**：
   - 从左上角开始，按行或者按列依次计算每个位置的路径数。

### 示例代码

```go
func uniquePaths(m int, n int) int {
    dp := make([][]int, m)
    for i := range dp {
        dp[i] = make([]int, n)
        dp[i][0] = 1
    }
    for j := 0; j < n; j++ {
        dp[0][j] = 1
    }
    for i := 1; i < m; i++ {
        for j := 1; j < n; j++ {
            dp[i][j] = dp[i-1][j] + dp[i][j-1]
        }
    }
    return dp[m-1][n-1]
}
```

### 复杂度分析

- **时间复杂度**：O(m \* n)，需要遍历整个 `m x n` 的方格。
- **空间复杂度**：O(m \* n)，需要一个 `m x n` 的二维数组来存储路径数。

### 总结

通过动态规划的方法，可以高效地计算出从左上角到右下角的所有不同路径数。关键在于合理地定义状态和状态转移方程，并进行适当的初始化。
