# 算法

## 动态规划

<!-- notecardId: 1736497953366 -->

动态规划（Dynamic Programming，简称 DP）是一种通过将复杂问题分解为更小的子问题来解决复杂问题的方法。它特别适用于具有重叠子问题和最优子结构性质的问题。

### 基本思想

动态规划的基本思想是将问题分解为子问题，并通过存储子问题的解来避免重复计算，从而提高效率。动态规划通常通过以下几步来解决问题：

1. **定义子问题**：将原问题分解为若干子问题。
2. **确定状态**：用一个或多个变量表示子问题的状态。
3. **状态转移方程**：找到子问题之间的关系，写出状态转移方程。
4. **初始条件和边界条件**：确定初始状态和边界条件。
5. **计算顺序**：确定计算子问题的顺序，通常是自底向上或自顶向下。

### 动态规划的步骤

1. **定义状态**：

   - 明确问题的状态，通常用一个或多个变量表示。
   - 例如，在最长回文子串问题中，状态是 `dp[i][j]`，表示子串 `s[i..j]` 是否是回文串。

2. **确定状态转移方程**：

   - 描述状态之间的关系，即如何从子问题的解推导出原问题的解。
   - 例如，在斐波那契数列中，状态转移方程是 `dp[i] = dp[i-1] + dp[i-2]`。

3. **初始化**：

   - 设置初始状态的值，通常是问题的最小规模情况。
   - 例如，在斐波那契数列中，`dp[0] = 0` 和 `dp[1] = 1`。

4. **计算顺序**：

   - 按照一定的顺序计算状态，通常是自底向上（从最小规模问题开始）或自顶向下（递归+记忆化）。
   - 例如，在斐波那契数列中，从 `dp[0]` 开始依次计算到 `dp[n]`。

5. **返回结果**：
   - 根据状态表返回原问题的解。
   - 例如，在最长回文子串问题中，返回最长回文子串的起始位置和长度。

### 动态规划的两种实现方式

#### 自底向上（迭代）

从最小规模问题开始，逐步计算到原问题。

例如，斐波那契数列的迭代实现：

```java
int fib(int n) {
    if (n <= 1) return n;
    int[] dp = new int[n + 1];
    dp[0] = 0;
    dp[1] = 1;
    for (int i = 2; i <= n; i++) {
        dp[i] = dp[i - 1] + dp[i - 2];
    }
    return dp[n];
}
```

#### 自顶向下（递归+记忆化）

从原问题开始，递归分解为子问题，并使用记忆化存储子问题的解。

例如，斐波那契数列的递归+记忆化实现：

```java
int fib(int n, int[] memo) {
    if (n <= 1) return n;
    if (memo[n] != 0) return memo[n]; // 如果已经计算过，直接返回
    memo[n] = fib(n - 1, memo) + fib(n - 2, memo); // 存储计算结果
    return memo[n];
}
```

### 问题

- Q: 为什么 dp 数组的大小通常设置为 (m+1) x (n+1) 而不是 m x n?
  > - 需要考虑问题的边界条件，并且动态规划的状态通常是从 0 开始的，为了正确处理这些边界条件，我们需要在 dp 数组中包含 i = 0 和 j = 0 的情况。dp 数组的大小需要是 (m+1) x (n+1)，以覆盖从 0 到 m 和从 0 到 n 。
  > - 避免数组越界。
  > - 使状态转移方程的逻辑更加清晰和简洁

### 示例

#### 斐波那契数列

斐波那契数列是动态规划的经典例子。斐波那契数列的定义如下：

$$
F(n) = \begin{cases}
0 & \text{if } n = 0 \\
1 & \text{if } n = 1 \\
F(n-1) + F(n-2) & \text{if } n > 1
\end{cases}
$$

使用动态规划来计算斐波那契数列，可以避免重复计算：

```go
func fibonacci(n int) int {
    if n <= 1 {
        return n
    }
    dp := make([]int, n+1)
    dp[1] = 1
    for i := 2; i <= n; i++ {
        dp[i] = dp[i-1] + dp[i-2]
    }
    return dp[n]
}
```

#### 背包问题

背包问题也是动态规划的经典应用之一。假设有一个背包，容量为 $W$，有 $n$ 个物品，每个物品有重量 $w_i$ 和价值 $v_i$。问如何选择物品使得在不超过背包容量的情况下，背包中的总价值最大。

状态定义：$dp[i][j]$ 表示前 $i$ 个物品在容量为 $j$ 的情况下的最大价值。

状态转移方程：

$$
dp[i][j] = \begin{cases}
dp[i-1][j] & \text{if } j < w_i \\
\max(dp[i-1][j], dp[i-1][j-w_i] + v_i) & \text{if } j \geq w_i
\end{cases}
$$

初始条件：$dp[0][j] = 0$，表示没有物品时的最大价值为 0。

```go
func knapsack(W int, weights []int, values []int, n int) int {
    dp := make([][]int, n+1)
    for i := range dp {
        dp[i] = make([]int, W+1)
    }
    for i := 1; i <= n; i++ {
        for w := 0; w <= W; w++ {
            if weights[i-1] <= w {
                dp[i][w] = max(dp[i-1][w], dp[i-1][w-weights[i-1]] + values[i-1])
            } else {
                dp[i][w] = dp[i-1][w]
            }
        }
    }
    return dp[n][W]
}

func max(a, b int) int {
    if a > b {
        return a
    }
    return b
}
```

#### 最长回文子串

- 最长回文子串问题是动态规划的另一个经典例子。给定一个字符串，找到其中最长的回文子串。
- 状态转移方程：`dp[i][j] = (s[i] == s[j]) && dp[i+1][j-1]`

#### 最长公共子序列(LCS)

状态转移方程：

```text
if (s1[i] == s2[j]):
    dp[i][j] = dp[i-1][j-1] + 1
else:
    dp[i][j] = max(dp[i-1][j], dp[i][j-1])
```

#### 最短路径问题

- Floyd-Warshall 算法和 Dijkstra 算法

### 动态规划的优缺点

- 优点：
  - 避免重复计算，提高效率。
  - 适用于具有重叠子问题和最优子结构的问题。
- 缺点：
  - 需要额外的空间存储子问题的解。
  - 对于状态空间较大的问题，可能会占用较多内存。

### 总结

动态规划是一种强大的算法设计方法，适用于解决许多经典的计算机科学问题。通过合理地定义状态和状态转移方程，可以将复杂问题高效地解决。动态规划是一种强大的算法设计方法，通过将问题分解为子问题并存储子问题的解，能够高效地解决许多复杂问题。

> 掌握动态规划的关键在于：
>
> - 理解问题的状态定义。
> - 找到正确的状态转移方程。
> - 选择合适的实现方式（自底向上或自顶向下）。

通过不断练习经典问题，可以逐渐掌握动态规划的思想和应用技巧。
