# 算法

## 动态规划

<!-- notecardId: 1736497953366 -->

动态规划（Dynamic Programming，简称 DP）是一种通过将复杂问题分解为更小的子问题来解决复杂问题的方法。它特别适用于具有重叠子问题和最优子结构性质的问题。

### 基本思想

动态规划的基本思想是将问题分解为子问题，并通过存储子问题的解来避免重复计算，从而提高效率。动态规划通常通过以下几步来解决问题：

1. **定义子问题**：将原问题分解为若干子问题。
2. **确定状态**：用一个或多个变量表示子问题的状态。
3. **状态转移方程**：找到子问题之间的关系，写出状态转移方程。
4. **初始条件和边界条件**：确定初始状态和边界条件。
5. **计算顺序**：确定计算子问题的顺序，通常是自底向上或自顶向下。

### 示例

#### 斐波那契数列

斐波那契数列是动态规划的经典例子。斐波那契数列的定义如下：

$$
F(n) = \begin{cases}
0 & \text{if } n = 0 \\
1 & \text{if } n = 1 \\
F(n-1) + F(n-2) & \text{if } n > 1
\end{cases}
$$

使用动态规划来计算斐波那契数列，可以避免重复计算：

```go
func fibonacci(n int) int {
    if n <= 1 {
        return n
    }
    dp := make([]int, n+1)
    dp[1] = 1
    for i := 2; i <= n; i++ {
        dp[i] = dp[i-1] + dp[i-2]
    }
    return dp[n]
}
```

#### 背包问题

背包问题也是动态规划的经典应用之一。假设有一个背包，容量为 $W$，有 $n$ 个物品，每个物品有重量 $w_i$ 和价值 $v_i$。问如何选择物品使得在不超过背包容量的情况下，背包中的总价值最大。

状态定义：$dp[i][j]$ 表示前 $i$ 个物品在容量为 $j$ 的情况下的最大价值。

状态转移方程：

$$
dp[i][j] = \begin{cases}
dp[i-1][j] & \text{if } j < w_i \\
\max(dp[i-1][j], dp[i-1][j-w_i] + v_i) & \text{if } j \geq w_i
\end{cases}
$$

初始条件：$dp[0][j] = 0$，表示没有物品时的最大价值为 0。

```go
func knapsack(W int, weights []int, values []int, n int) int {
    dp := make([][]int, n+1)
    for i := range dp {
        dp[i] = make([]int, W+1)
    }
    for i := 1; i <= n; i++ {
        for w := 0; w <= W; w++ {
            if weights[i-1] <= w {
                dp[i][w] = max(dp[i-1][w], dp[i-1][w-weights[i-1]] + values[i-1])
            } else {
                dp[i][w] = dp[i-1][w]
            }
        }
    }
    return dp[n][W]
}

func max(a, b int) int {
    if a > b {
        return a
    }
    return b
}
```

### 总结

动态规划是一种强大的算法设计方法，适用于解决许多经典的计算机科学问题。通过合理地定义状态和状态转移方程，可以将复杂问题高效地解决。
